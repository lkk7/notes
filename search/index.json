[{"content":"Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety.\n(For Python, type hinting in every code snippet has been omitted for simplicity)\nPython Data model, objects Python\u0026rsquo;s reference [1] sums up its concept of objects in a concise way:\n\u0026ldquo;Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The is operator compares the identity of two objects; the id() function returns an integer representing its identity. [\u0026hellip;]\nThe value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable.\u0026quot;\nWe can check that every object has its identity, represented by an ID. Note that this is guaranteed to be a memory address in CPython, but not in other implementations.\n\u0026gt;\u0026gt;\u0026gt; number = 1 \u0026gt;\u0026gt;\u0026gt; id(number) 4402092336  Constants, mutability There is no concept of const in Python, so we cannot simply define a const variable like in many other languages. However, as said in earlier section, objects can be mutable or immutable.\nLet\u0026rsquo;s try to modify an object of type list (it is mutable) and see if it affects its identity.\n\u0026gt;\u0026gt;\u0026gt; numbers = [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; id(numbers) 4404611136 \u0026gt;\u0026gt;\u0026gt; numbers[0] = 123 \u0026gt;\u0026gt;\u0026gt; numbers [123, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; id(numbers) 4404611136  As we see, modifying a mutable object does not change its identity. Let\u0026rsquo;s try to do the same thing with an object of type str, which is immutable.\n\u0026gt;\u0026gt;\u0026gt; letters = \u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; letters[0] = \u0026quot;!\u0026quot; Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; TypeError: 'str' object does not support item assignment  We cannot modify immutable objects in-place. If we want to modify a variable which holds a string, we have to assign a new string object to that variable.\n\u0026gt;\u0026gt;\u0026gt; letters = \u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; id(letters) 4404659376 \u0026gt;\u0026gt;\u0026gt; # Replace the occurence of 'a' with '!' by assigning a new string here \u0026gt;\u0026gt;\u0026gt; letters = letters.replace('a', '!', 1) \u0026gt;\u0026gt;\u0026gt; id(letters) 4404660336  Here are the essential data types divided on their mutability:\n Immutable: str, tuple, int, float, frozenset (an immutable set), bytes Mutable: list, dict, set, bytearray (a mutable version of bytes), user-defined classes.  If an immutable sequence like a tuple contains a mutable object (or really a reference to it) like a list, then this list can be modified in-place. We can\u0026rsquo;t modify the reference itself in the sequence, but we can modify the object it points to.\n\u0026gt;\u0026gt;\u0026gt; immutable = (1, 2, 3, [100, 200, 300]) \u0026gt;\u0026gt;\u0026gt; id(immutable[3]) 4302923264 \u0026gt;\u0026gt;\u0026gt; immutable[3] = [10, 20, 30] # We can't modify the reference Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; TypeError: 'tuple' object does not support item assignment \u0026gt;\u0026gt;\u0026gt; immutable[3][2] = 999 # But we can get what it points to and modify that \u0026gt;\u0026gt;\u0026gt; id(immutable[3]) 4302923264 \u0026gt;\u0026gt;\u0026gt; immutable (1, 2, 3, [100, 200, 999])  This points us to the fact that \u0026ldquo;immutability\u0026rdquo; doesn\u0026rsquo;t really mean \u0026ldquo;constness\u0026rdquo;. We can\u0026rsquo;t change the immutable object itself, but if it holds references to something mutable, we can modify that thing being pointed to.\nMoreover, we can just change what the variable holds.\n\u0026gt;\u0026gt;\u0026gt; immutable = (1, 2, 3) # Variable points to an immutable object \u0026gt;\u0026gt;\u0026gt; immutable = (3, 2, 1) # So what, we can just change that  Creating \u0026ldquo;constants\u0026rdquo; in Python We can emulate a constant like this:\n\u0026gt;\u0026gt;\u0026gt; def GET_X(): ... return \u0026quot;a1scdf8sfacd4cl\u0026quot; ... \u0026gt;\u0026gt;\u0026gt; GET_X() 'a1scdf8sfacd4cl' \u0026gt;\u0026gt;\u0026gt; GET_X() = 100 File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1 GET_X() = 100 ^ SyntaxError: cannot assign to function call  But it requires us to remember about the function call parentheses. Also, it has the overhead of a function.\nFor classes, we can create read-only properties.\n\u0026gt;\u0026gt;\u0026gt; class Something: ... def __init__(self, x): ... self._x = x ... @property ... def x(self): ... return self._x ... \u0026gt;\u0026gt;\u0026gt; something = Something(1) \u0026gt;\u0026gt;\u0026gt; something.x 1 \u0026gt;\u0026gt;\u0026gt; something.x = 2 Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; AttributeError: can't set attribute  An interesting case Python\u0026rsquo;s reference [1] says:\nDefault parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified.\nThat means that this is possible:\n\u0026gt;\u0026gt;\u0026gt; def print_mirrored(numbers=[1,2,3]): ... numbers += numbers[::-1] ... print(numbers) ... \u0026gt;\u0026gt;\u0026gt; print_mirrored() [1, 2, 3, 3, 2, 1] \u0026gt;\u0026gt;\u0026gt; print_mirrored() [1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1]  We see that changes to the default numbers parameter are saved between calls. If we don\u0026rsquo;t want that effect, we can choose to use None:\n\u0026gt;\u0026gt;\u0026gt; def print_mirrored(numbers=None): ... if numbers is None: ... numbers = [1, 2, 3] ... numbers += numbers[::-1] ... print(numbers) ... \u0026gt;\u0026gt;\u0026gt; print_mirrored() [1, 2, 3, 3, 2, 1] \u0026gt;\u0026gt;\u0026gt; print_mirrored() [1, 2, 3, 3, 2, 1]  C++ Const type qualifier and const-qualified member functions In contrast to Python, we can make objects constant and we do that by using a constant type qualifier. Cppreference [2] tells us what is a const object:\nAn object whose type is const-qualified, or a non-mutable subobject of a const object. Such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.\nWe declare the constness together with the type by the const keyword:\nconst int a = 0; // a = 10; // Error  But the const keyword can also be used to const-qualify a member function (a function that is a member of a class) [2]. In such case, inside the body of that function *this is seen as const-qualified. Thus, we can\u0026rsquo;t modify any other members here and only member functions that are const-qualified can be called here.\nclass Something { int member = 1; void modify_member(); void modify_member_const() const; void non_const_function() {} void const_function() const {}; }; void Something::modify_member() { member = 2; // Will work non_const_function(); // Will work } // Will not work void Something::modify_member_const() const { const_function(); // Will work // non_const_function(); // Won't work (error) // member = 2; // Won't work (error) }  There are some tools that make the compiler \u0026ldquo;forget\u0026rdquo; for a while that something is const in a specific context.\nThe first one is a mutable keyword. When we declare a class member as mutable, it can be modified even in const-qualified member functions.\nclass Something { int member = 1; mutable int mutable_member = 1; void const_function() const; }; void Something::const_function() const{ mutable_member = 2; // Will work // member = 2; // Won't work (error) }  As cppreference says [2]: Mutable is used to specify that the member does not affect the externally visible state of the class. Example usage includes mutexes.\nAnother tool used to \u0026ldquo;forget\u0026rdquo; the constness of something is const_cast. It can be used to remove constness from const pointers/references that point to a non-const object.\nint i = 1; const int* ptr = \u0026amp;i; *const_cast\u0026lt;int*\u0026gt;(ptr) = 2;  If the object (i) pointed to was actually const, this would lead to undefined behavior. const_cast is used rather rarely.\nconstexpr There\u0026rsquo;s also the great constexpr, about which cppreference [2] says:\nThe constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given). The \u0026ldquo;at-compile-time\u0026rdquo; thing is still evolving, with consteval and constinit coming in the future. That\u0026rsquo;s why I will probably focus on these things in a different post.\nAn interesting case Const declarations might get tricky when using type aliases.\nusing int_ptr = int*; int x = 1; const int* first = \u0026amp;x; // const int* as expected const int_ptr second = \u0026amp;x; // This is actually int* const  The first pointer will be of type const int* (non-const pointer to a const int). However, compiler will make the second one a int* const (const pointer to a non-const int). Why is this the case? It\u0026rsquo;s because the second pointer gets evaluated to int_ptr const second, which gives int* const second.\nA Good FAQ about constness in C++ https://isocpp.org/wiki/faq/const-correctness\nJavaScript Constants, mutability All primitive data types (string, number, bigint, boolean, undefined, symbol, null) are immutable [3]. Objects and arrays are mutable. As in Python, variables pointing to immutable data can just start pointing to a new value.\nlet immutable = \u0026quot;x\u0026quot;; // the \u0026quot;x\u0026quot; is immutable immutable = \u0026quot;y\u0026quot;; // but we can just abandon the \u0026quot;x\u0026quot; let x = {a: 1}; x.a = 100; // We can modify an object console.log(x); // {a: 100}  ES6 introduced the \u0026lsquo;const\u0026rsquo; keyword for variables. This prevents reassignment:\nconst value = 1; value = 2; // Uncaught TypeError: Assignment to constant variable.  We have to initialize a const variable immediately:\nconst x; // Uncaught SyntaxError: Missing initializer in const declaration  const, just like let, has block scope:\nconst x = 1; { const x = 2; console.log(x); // 2 } console.log(x); // 1  Important: const does not make the object pointed to immutable – it just prevents reassignment:\nconst x = {a: 1}; x.a = 100; console.log(x); // {a: 100}  To make an object immutable, we can use Object.freeze. This does not work on nested objects:\nlet x = {a: 1, nested: {b: 1}}; Object.freeze(x); x.a = 2; x.new = \u0026quot;new\u0026quot;; x.nested.b = 2; console.log(x); // {a: 1, nested: {b: 2}}  As we can see, this situation is very similar to Python\u0026rsquo;s case (immutable tuple holding a mutable list).\nAn interesting case Function declarations get hoisted to current scope\u0026rsquo;s top, so the function can be used before the declaration.\nconsole.log(linearFunction(2, 1, 10)); // 21 function linearFunction(a, b, x) { return a * x + b; }  A const arrow function prevents this (because it is block-scoped) while also preventing reassignment:\nconsole.log(linearFunction(2, 1, 10)); // Error const linearFunction = (a, b, x) =\u0026gt; a * x + b; console.log(linearFunction(2, 1, 10)); // 21 linearFunction = () =\u0026gt; {} // Error  Another option is a mix of these two options:\nconsole.log(linearFunction(2, 1, 10)); // Error const linearFunction = function linearFunction(a, b, x) { return a * x + b; } console.log(linearFunction(2, 1, 10)); // 21 linearFunction = function linearFunction(a, b, x) {}; // Error  Which approach is better depends on the situation. Arrow functions have their limitations as seen here.\nSources:  [1] https://docs.python.org/3/reference Python Software Foundation. The Python Language Reference [2] https://en.cppreference.com cppreference.com – C and C++ reference [3] https://developer.mozilla.org – MDN Web Docs ","date":"2021-04-21","permalink":"https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js/","tags":["python","c++","javascript"],"title":"Basic overview of constants/mutability in Python, C++ and JavaScript"},{"content":"This subject may seem complicated: generators create generator iterators (which are iterables). To make that sentence sound understandable, here\u0026rsquo;s a short note about the topic.\n(Type hinting in every code snippet has been omitted for simplicity)\nIterables The docs [1] briefly explain iterables:\nAn object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects [\u0026hellip;] Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), …).\nIn essence, iterables are everything that you can loop over with a for loop.\nAn important detail is that they have a method __iter__() which returns an iterator for them (or an equivalent iter() built-in function).\nIterators An iterator is an object used to iterate over iterables. When we loop over a list with a for statement, the iterator is created behind the scenes and we don\u0026rsquo;t have to worry about it. However, we can try to manually loop over the list with an iterator like this:\nnumbers = [1, 2, 3] it = iter(numbers) # This is the iterator object print(it.__next__()) # 1 print(it.__next__()) # 2 print(next(it)) # 3 (this is the same thing as __next__()) print(it.__next__()) # StopIteration exception  As we see, an iterator gets \u0026ldquo;worn out\u0026rdquo; after it has iterated over everything it had to. It throws a special StopIteration exception. We\u0026rsquo;d have to create a new iterator if we wanted to iterate again. Besides the __next__() method (which is synonymous to calling next() on the iterator, as seen in example above), the iterator should also have a method __iter__ [1]. It just returns the iterator itself, making any iterator also an iterable (because, as I pointed out in the earlier section, every iterable has a __next__() method).\na = iter([1, 2, 3]) print(a is a.__iter__()) # True  Generators A generator is a function which returns a generator iterator (just a special kind of iterator). This iterator is returned through usage of yield keyword. As the docs [1] say:\nEach yield temporarily suspends processing, remembering the location execution state (including local variables and pending try-statements). When the generator iterator resumes, it picks up where it left off (in contrast to functions which start fresh on every invocation).\nLet\u0026rsquo;s clear this up with an example:\ndef double_range(start, stop): for i in range(start, stop): yield 2 * i it = double_range(0, 3) # our generator iterator, has the __next__ method print(it) # \u0026lt;generator object double at 0x10e900820\u0026gt; print(it.__next__()) # 0 print(it.__next__()) # 2 print(next(it)) # 4 print(next(it)) # StopIteration exception  The shortest and simplest explanation is: the generator iterator returned from our double_range function is like a list, but we retrieve elements one at a time, when they are needed. That is called lazy evaluation. Subsequent calls to __next__() get subsequent elements. They aren\u0026rsquo;t all calculated at it = double_range(0, 3) line. They would be calculated at definition time if we used a list:\na = double_range(0, 3) print(a) # \u0026lt;generator object double_range at 0x104cd9200\u0026gt; a = [2 * i for i in range(0, 3)] print(a) # [0, 2, 4]  In fact, we used list comprehension syntax there. Is there a \u0026ldquo;generator comprehension\u0026rdquo;? Yes, and we call it a generator expression:\na = (2 * i for i in range(0, 3)) print(a) # \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x104cd9660\u0026gt; print(next(a)) # 0 print(a.__next__()) # 2 print(next(a)) # 4 print(next(a)) # StopIteration exception  Definitely shorter syntax than a full function, and it does the same thing. However, it could be discussed if it\u0026rsquo;s more readable. Also, do not mistake generator expressions for tuples.\nA very short note about use cases for generators I believe that the information presented here is more than enough to start using generators. But why would we want to use them? They may seem like a worse list/tuple at first. It turns out there\u0026rsquo;s a big advantage to them – memory usage. As we know now, generators calculate elements of a sequence one at a time. That may save memory and allow us to process large files, theoretically infinite sequences or \u0026ldquo;online\u0026rdquo; data streams.\nThe simplest example – creating infinite sequences over which we can iterate easily:\ndef numbers(): n = -999999999 while True: yield n n += 1 for i in numbers(): print(i) # -999999999, -999999998, ...  Sources:  [1] https://docs.python.org Python Software Foundation. Python Documentation ","date":"2020-07-11","permalink":"https://www.lkk7.com/notes/post/2020-07-11-a-short-note-on-iterables-iterators-generators-in-python/","tags":["python"],"title":"A short note on iterables, iterators, generators in Python"},{"content":"numpy.indices was a function that I really couldn\u0026rsquo;t \u0026ldquo;get\u0026rdquo; for a long time. But with help of this Stack Overflow answer (I am the question asker) I have grasped it. Here I will present the idea with examples.\nThe complicated explanation We pass a dimensions argument made of n elements, for example (7) or (2, 3). numpy.indices(dimensions) will return an array (a numpy.ndarray) made of n subarrays, in which each subarray is dimensions-shaped and contains its indices varying only in the corresponding dimension.\nThe essential examples The explanation may seem complicated, but the examples will make it clearer.\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; result = np.indices([7]) \u0026gt;\u0026gt;\u0026gt; len(result) 1 \u0026gt;\u0026gt;\u0026gt; result[0] array([0, 1, 2, 3, 4, 5, 6])  This is the simplest case. We have passed [7] as the dimensions argument, which represents a 1D array with 7 elements.\nFor each dimension (so in this case just for one) the result gets a [7]-shaped subarray which is made of indices (0, 1, \u0026hellip;) counted only in the corresponding dimension.\nIn the example there is only one dimension available, so the result only consists of one subarray with indices going along this dimension.\nThe next example is the most important one:\n\u0026gt;\u0026gt;\u0026gt; result = np.indices([2, 3]) \u0026gt;\u0026gt;\u0026gt; len(result) 2 \u0026gt;\u0026gt;\u0026gt; result[0] array([[0, 0, 0], [1, 1, 1]]) \u0026gt;\u0026gt;\u0026gt; result[1] array([[0, 1, 2], [0, 1, 2]])  Now, we have passed [2, 3] as the dimensions argument, which represents a 2D array with 2 rows and 3 columns.\nFor each dimension (we have two of them here) the result gets a [2, 3]-shaped subarray made of indices counted only in the corresponding dimension. So the first subarray has indices counted along the rows, while the second one counts along the column axis.\nThat\u0026rsquo;s it! We could go with higher dimensions, but for basic usage that\u0026rsquo;s unnecessary.\nUse cases numpy.indices is very useful when we want to define a matrix by its indices, which is common in maths/physics. For example: \u0026ldquo;A 3x5 matrix M where M_ij = 2*i + j\u0026rdquo; defines a matrix where each element is equal to its row index times two plus its column index.\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; i, j = np.indices([3, 5]) \u0026gt;\u0026gt;\u0026gt; M = 2 * i + j \u0026gt;\u0026gt;\u0026gt; M array([[0, 1, 2, 3, 4], [2, 3, 4, 5, 6], [4, 5, 6, 7, 8]])  Another interesting thing is that those indices can be treated as coordinates in space.\nThat makes numpy.indices a simple choice for defining fields of values that depend on x, y (possibly z and more). In maths/physics we call those fields scalar. Unfortunately, the obvious limitation is that we can only deal with discrete coordinates.\n","date":"2018-08-05","permalink":"https://www.lkk7.com/notes/post/2019-08-01-about-numpy-indices/","tags":["python"],"title":"About numpy.indices"}]