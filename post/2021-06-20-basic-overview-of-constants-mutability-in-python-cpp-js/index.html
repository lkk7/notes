<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=HandheldFriendly content="True">
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=generator content="Hugo 0.88.1">
<link rel="shortcut icon" href=https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico>
<title>Basic overview of constants/mutability in Python, C++ and JavaScript - My notes</title>
<meta name=author content="Łukasz Łapiński">
<meta name=description content="Constants/mutability in Python, C++ and JavaScript">
<meta name=keywords content="python,c++,javascript">
<meta property="og:title" content="Basic overview of constants/mutability in Python, C++ and JavaScript">
<meta name=twitter:title content="Basic overview of constants/mutability in Python, C++ and JavaScript">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js/"><meta property="og:description" content="Constants/mutability in Python, C++ and JavaScript">
<meta name=twitter:description content="Constants/mutability in Python, C++ and JavaScript"><meta property="og:image" content="https://www.lkk7.com/img/og.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://www.lkk7.com/img/og.png"><meta property="article:published_time" content="2021-04-21T00:00:00+02:00"><meta property="article:modified_time" content="2021-04-21T00:00:00+02:00">
<style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style>
<link rel=stylesheet href=https://www.lkk7.com/notes/assets/css/fuji.min.css>
</head>
<body data-theme=dark data-theme-auto=false>
<script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script>
<header>
<div class="container-lg clearfix">
<div class="col-12 header">
<a class=title-main href=https://www.lkk7.com/notes>My notes</a>
<span class=title-sub>Notes I'd like to keep in external memory.</span>
</div>
</div>
</header>
<main>
<div class="container-lg clearfix">
<div class="col-12 col-md-9 float-left content">
<article>
<h2 class="post-item post-title">
<a href=https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js/>Basic overview of constants/mutability in Python, C++ and JavaScript</a>
</h2>
<div class="post-item post-meta">
<span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-04-21</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1870 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/notes/tags/python>python</a>&nbsp;<a href=/notes/tags/c++>c++</a>&nbsp;<a href=/notes/tags/javascript>javascript</a>&nbsp;</span>
</div>
<div class="post-content markdown-body">
<p>Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety.</p>
<p><strong>(For Python, type hinting in every code snippet has been omitted for simplicity)</strong></p>
<h2 id=python>Python</h2>
<h3 id=data-model-objects>Data model, objects</h3>
<p>Python&rsquo;s reference [1] sums up its concept of objects in a concise way:<br>
<em>&ldquo;Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The <code>is</code> operator compares the identity of two objects; the <code>id()</code> function returns an integer representing its identity. [&mldr;]<br>
The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable."</em></p>
<p>We can check that every object has its identity, represented by an ID. Note that this is guaranteed to be a memory address in CPython, but not in other implementations.</p>
<pre><code class=language-python>&gt;&gt;&gt; number = 1
&gt;&gt;&gt; id(number)
4402092336
</code></pre>
<h3 id=constants-mutability>Constants, mutability</h3>
<p>There is no concept of <code>const</code> in Python, so we cannot simply define a <code>const</code> variable like in many other languages.
However, as said in earlier section, objects can be mutable or immutable.<br>
Let&rsquo;s try to modify an object of type <code>list</code> (it is mutable) and see if it affects its identity.</p>
<pre><code class=language-python>&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]
&gt;&gt;&gt; id(numbers)
4404611136
&gt;&gt;&gt; numbers[0] = 123
&gt;&gt;&gt; numbers
[123, 2, 3, 4, 5]
&gt;&gt;&gt; id(numbers)
4404611136
</code></pre>
<p>As we see, modifying a mutable object does not change its identity.
Let&rsquo;s try to do the same thing with an object of type <code>str</code>, which is immutable.</p>
<pre><code class=language-python>&gt;&gt;&gt; letters = &quot;abcdefg&quot;
&gt;&gt;&gt; letters[0] = &quot;!&quot;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
</code></pre>
<p>We cannot modify immutable objects in-place. If we want to modify a variable which holds a string, we have to assign a new string object to that variable.</p>
<pre><code class=language-python>&gt;&gt;&gt; letters = &quot;abcdefg&quot;
&gt;&gt;&gt; id(letters)
4404659376
&gt;&gt;&gt; # Replace the occurence of 'a' with '!' by assigning a new string here
&gt;&gt;&gt; letters = letters.replace('a', '!', 1)
&gt;&gt;&gt; id(letters)
4404660336
</code></pre>
<p>Here are the essential data types divided on their mutability:</p>
<ul>
<li>Immutable: <code>str</code>, <code>tuple</code>, <code>int</code>, <code>float</code>, <code>frozenset</code> (an immutable <code>set</code>), <code>bytes</code></li>
<li>Mutable: <code>list</code>, <code>dict</code>, <code>set</code>, <code>bytearray</code> (a mutable version of <code>bytes</code>), user-defined classes.</li>
</ul>
<p>If an immutable sequence like a <code>tuple</code> contains a mutable object (or really a reference to it) like a <code>list</code>, then this list can be modified in-place. We can&rsquo;t modify the reference itself in the sequence, but we can modify the object it points to.</p>
<pre><code class=language-python>&gt;&gt;&gt; immutable = (1, 2, 3, [100, 200, 300])
&gt;&gt;&gt; id(immutable[3])
4302923264
&gt;&gt;&gt; immutable[3] = [10, 20, 30] # We can't modify the reference
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment
&gt;&gt;&gt; immutable[3][2] = 999 # But we can get what it points to and modify that
&gt;&gt;&gt; id(immutable[3])
4302923264
&gt;&gt;&gt; immutable
(1, 2, 3, [100, 200, 999])
</code></pre>
<p>This points us to the fact that &ldquo;immutability&rdquo; doesn&rsquo;t really mean &ldquo;constness&rdquo;.
We can&rsquo;t change the immutable object itself, but if it holds references to something mutable, we can modify that thing being pointed to.<br>
Moreover, we can just change what the variable holds.</p>
<pre><code class=language-python>&gt;&gt;&gt; immutable = (1, 2, 3) # Variable points to an immutable object
&gt;&gt;&gt; immutable = (3, 2, 1) # So what, we can just change that
</code></pre>
<h3 id=creating-constants-in-python>Creating &ldquo;constants&rdquo; in Python</h3>
<p>We can emulate a constant like this:</p>
<pre><code class=language-python>&gt;&gt;&gt; def GET_X():
...     return &quot;a1scdf8sfacd4cl&quot;
... 
&gt;&gt;&gt; GET_X()
'a1scdf8sfacd4cl'
&gt;&gt;&gt; GET_X() = 100
  File &quot;&lt;stdin&gt;&quot;, line 1
    GET_X() = 100
    ^
SyntaxError: cannot assign to function call
</code></pre>
<p>But it requires us to remember about the function call parentheses. Also, it has the overhead of a function.<br>
For classes, we can create read-only properties.</p>
<pre><code class=language-python>&gt;&gt;&gt; class Something:
...     def __init__(self, x):
...         self._x = x
...     @property
...     def x(self):
...         return self._x
...
&gt;&gt;&gt; something = Something(1)
&gt;&gt;&gt; something.x
1
&gt;&gt;&gt; something.x = 2
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre>
<h3 id=an-interesting-case>An interesting case</h3>
<p>Python&rsquo;s reference [1] says:<br>
<em>Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified.</em></p>
<p>That means that this is possible:</p>
<pre><code class=language-python>&gt;&gt;&gt; def print_mirrored(numbers=[1,2,3]):
...     numbers += numbers[::-1]
...     print(numbers)
... 
&gt;&gt;&gt; print_mirrored()
[1, 2, 3, 3, 2, 1]
&gt;&gt;&gt; print_mirrored()
[1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1]
</code></pre>
<p>We see that changes to the default <code>numbers</code> parameter are saved between calls. If we don&rsquo;t want that effect, we can choose to use <code>None</code>:</p>
<pre><code class=language-python>&gt;&gt;&gt; def print_mirrored(numbers=None):
...     if numbers is None:
...         numbers = [1, 2, 3]
...     numbers += numbers[::-1]
...     print(numbers)
... 
&gt;&gt;&gt; print_mirrored()
[1, 2, 3, 3, 2, 1]
&gt;&gt;&gt; print_mirrored()
[1, 2, 3, 3, 2, 1]
</code></pre>
<h2 id=c>C++</h2>
<h3 id=const-type-qualifier-and-const-qualified-member-functions>Const type qualifier and const-qualified member functions</h3>
<p>In contrast to Python, we can make objects constant and we do that by using a constant type qualifier. Cppreference [2] tells us what is a const object:<br>
<em>An object whose type is const-qualified, or a non-mutable subobject of a const object. Such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.</em></p>
<p>We declare the constness together with the type by the <code>const</code> keyword:</p>
<pre><code class=language-cpp>const int a = 0;
// a = 10;       // Error
</code></pre>
<p>But the <code>const</code> keyword can also be used to const-qualify a member function (a function that is a member of a class) [2]. In such case, inside the body of that function <code>*this</code> is seen as const-qualified. Thus, we can&rsquo;t modify any other members here and only member functions that are const-qualified can be called here.</p>
<pre><code class=language-cpp>class Something {
    int member = 1;
    void modify_member();
    void modify_member_const() const;
    void non_const_function() {}
    void const_function() const {};
};

void Something::modify_member() {
    member = 2;           // Will work
    non_const_function(); // Will work
}

// Will not work
void Something::modify_member_const() const {
    const_function();        // Will work
    // non_const_function(); // Won't work (error)
    // member = 2;           // Won't work (error)
}
</code></pre>
<p>There are some tools that make the compiler &ldquo;forget&rdquo; for a while that something is const in a specific context.</p>
<p>The first one is a <code>mutable</code> keyword. When we declare a class member as <code>mutable</code>, it can be modified even in const-qualified member functions.</p>
<pre><code class=language-cpp>class Something {
    int member = 1;
    mutable int mutable_member = 1;
    void const_function() const;
};

void Something::const_function() const{
    mutable_member = 2; // Will work
    // member = 2;         // Won't work (error)
}
</code></pre>
<p>As cppreference says [2]: <em>Mutable is used to specify that the member does not affect the externally visible state of the class</em>. Example usage includes mutexes.</p>
<p>Another tool used to &ldquo;forget&rdquo; the constness of something is <code>const_cast</code>. It can be used to remove constness from const pointers/references that point to a non-const object.</p>
<pre><code class=language-cpp>int i = 1;
const int* ptr = &amp;i;
*const_cast&lt;int*&gt;(ptr) = 2;
</code></pre>
<p><strong>If the object (<code>i</code>) pointed to was actually <code>const</code>, this would lead to undefined behavior.</strong> <code>const_cast</code> is used rather rarely.</p>
<h3 id=constexpr>constexpr</h3>
<p>There&rsquo;s also the great <code>constexpr</code>, about which cppreference [2] says:<br>
<em>The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given).</em>
The &ldquo;at-compile-time&rdquo; thing is still evolving, with <code>consteval</code> and <code>constinit</code> coming in the future. That&rsquo;s why I will probably focus on these things in a different post.</p>
<h3 id=an-interesting-case-1>An interesting case</h3>
<p>Const declarations might get tricky when using type aliases.</p>
<pre><code class=language-cpp>using int_ptr = int*;

int x = 1;
const int* first = &amp;x;     // const int* as expected
const int_ptr second = &amp;x; // This is actually int* const
</code></pre>
<p>The <code>first</code> pointer will be of type <code>const int*</code> (non-const pointer to a const int). However, compiler will make the <code>second</code> one a <code>int* const</code> (const pointer to a non-const int). Why is this the case? It&rsquo;s because the <code>second</code> pointer gets evaluated to <code>int_ptr const second</code>, which gives <code>int* const second</code>.</p>
<h3 id=a-good-faq-about-constness-in-c>A Good FAQ about constness in C++</h3>
<p><a href=https://isocpp.org/wiki/faq/const-correctness target=_blank>https://isocpp.org/wiki/faq/const-correctness</a></p>
<h2 id=javascript>JavaScript</h2>
<h3 id=constants-mutability-1>Constants, mutability</h3>
<p>All primitive data types (string, number, bigint, boolean, undefined, symbol, null) are immutable [3]. Objects and arrays are mutable. As in Python, variables pointing to immutable data can just start pointing to a new value.</p>
<pre><code class=language-js>let immutable = &quot;x&quot;;   // the &quot;x&quot; is immutable
immutable = &quot;y&quot;;       // but we can just abandon the &quot;x&quot;

let x = {a: 1};
x.a = 100;             // We can modify an object
console.log(x);        // {a: 100}
</code></pre>
<p>ES6 introduced the &lsquo;const&rsquo; keyword for variables. This prevents reassignment:</p>
<pre><code class=language-js>const value = 1;
value = 2;
// Uncaught TypeError: Assignment to constant variable.
</code></pre>
<p>We have to initialize a <code>const</code> variable immediately:</p>
<pre><code class=language-js>const x; // Uncaught SyntaxError: Missing initializer in const declaration
</code></pre>
<p><code>const</code>, just like <code>let</code>, has block scope:</p>
<pre><code class=language-js>const x = 1;
{
    const x = 2;
    console.log(x); // 2
}
console.log(x);     // 1
</code></pre>
<p>Important: <code>const</code> does not make the object pointed to immutable – it just prevents reassignment:</p>
<pre><code class=language-js>const x = {a: 1};
x.a = 100;
console.log(x); // {a: 100}
</code></pre>
<p>To make an object immutable, we can use <code>Object.freeze</code>. This does not work on nested objects:</p>
<pre><code class=language-js>let x = {a: 1, nested: {b: 1}};
Object.freeze(x);
x.a = 2;
x.new = &quot;new&quot;;
x.nested.b = 2;
console.log(x); // {a: 1, nested: {b: 2}}
</code></pre>
<p>As we can see, this situation is very similar to Python&rsquo;s case (immutable <code>tuple</code> holding a mutable <code>list</code>).</p>
<h3 id=an-interesting-case-2>An interesting case</h3>
<p>Function declarations get hoisted to current scope&rsquo;s top, so the function can be used before the declaration.</p>
<pre><code class=language-js>console.log(linearFunction(2, 1, 10)); // 21
function linearFunction(a, b, x) {
    return a * x + b;
}
</code></pre>
<p>A <code>const</code> arrow function prevents this (because it is block-scoped) while also preventing reassignment:</p>
<pre><code class=language-js>console.log(linearFunction(2, 1, 10));          // Error
const linearFunction = (a, b, x) =&gt; a * x + b;
console.log(linearFunction(2, 1, 10));          // 21
linearFunction = () =&gt; {}                       // Error
</code></pre>
<p>Another option is a mix of these two options:</p>
<pre><code class=language-js>console.log(linearFunction(2, 1, 10));                    // Error  
const linearFunction = function linearFunction(a, b, x) {
    return a * x + b;
}
console.log(linearFunction(2, 1, 10));                    // 21
linearFunction = function linearFunction(a, b, x) {};     // Error
</code></pre>
<p>Which approach is better depends on the situation. Arrow functions have their limitations <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions target=_blank>as seen here</a>.</p>
<h2 id=sources>Sources:</h2>
<ul>
<li>[1] <a href=https://docs.python.org/3/reference target=_blank>https://docs.python.org/3/reference</a> Python Software Foundation. The Python Language Reference</li>
<li>[2] <a href=https://en.cppreference.com target=_blank>https://en.cppreference.com</a> cppreference.com – C and C++ reference</li>
<li>[3] <a href=https://developer.mozilla.org target=_blank>https://developer.mozilla.org</a> – MDN Web Docs</li>
</ul>
</div>
</article>
</div>
<aside class="col-12 col-md-3 float-left sidebar">
<div class="sidebar-item sidebar-pages">
<h3>Pages</h3>
<ul>
<li>
<a href=/notes/>Home (notes)</a>
</li>
<li>
<a href=https://www.lkk7.com>About me</a>
</li>
<li>
<a href=/notes/archives/>Archives</a>
</li>
<li>
<a href=/notes/search/>Search</a>
</li>
<li>
<a href=/notes/index.xml>RSS</a>
</li>
</ul>
</div>
<div class="sidebar-item sidebar-tags">
<h3>Tags</h3>
<div>
<span>
<a href=/notes/tags/c++/>c++</a>
</span>
<span>
<a href=/notes/tags/javascript/>javascript</a>
</span>
<span>
<a href=/notes/tags/python/>python</a>
</span>
</div>
</div>
</aside>
</div>
<div class=btn>
<div class=btn-menu id=btn-menu>
<i class="iconfont icon-grid-sharp"></i>
</div>
<div class=btn-toggle-mode>
<i class="iconfont icon-contrast-sharp"></i>
</div>
<div class=btn-scroll-top>
<i class="iconfont icon-chevron-up-circle-sharp"></i>
</div>
</div>
<aside class=sidebar-mobile style=display:none>
<div class=sidebar-wrapper>
<div class="sidebar-item sidebar-pages">
<h3>Pages</h3>
<ul>
<li>
<a href=/notes/>Home (notes)</a>
</li>
<li>
<a href=https://www.lkk7.com>About me</a>
</li>
<li>
<a href=/notes/archives/>Archives</a>
</li>
<li>
<a href=/notes/search/>Search</a>
</li>
<li>
<a href=/notes/index.xml>RSS</a>
</li>
</ul>
</div>
<div class="sidebar-item sidebar-tags">
<h3>Tags</h3>
<div>
<span>
<a href=/notes/tags/c++/>c++</a>
</span>
<span>
<a href=/notes/tags/javascript/>javascript</a>
</span>
<span>
<a href=/notes/tags/python/>python</a>
</span>
</div>
</div>
</div>
</aside>
</main>
<footer>
<div class="container-lg clearfix">
<div class="col-12 footer">
<span>&copy; 2020-2021
<a href=https://www.lkk7.com/notes>Łukasz Łapiński</a>
| <a href=https://github.com/lkk7/notes>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a>
</span>
</div>
</div>
</footer>
<script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/notes/assets/js/fuji.min.js></script>
</body>
</html>