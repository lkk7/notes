<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Basic overview of constants/mutability in Python, C++ and JavaScript | lkk7/notes</title><meta name=keywords content="python,c++,javascript"><meta name=description content="Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety."><meta name=author content="lkk7"><link rel=canonical href=https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js-copy/><link crossorigin=anonymous href=/notes/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/notes/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.lkk7.com/notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.lkk7.com/notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.lkk7.com/notes/favicon-32x32.png><link rel=apple-touch-icon href=https://www.lkk7.com/notes/apple-touch-icon.png><link rel=mask-icon href=https://www.lkk7.com/notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Basic overview of constants/mutability in Python, C++ and JavaScript"><meta property="og:description" content="Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety."><meta property="og:type" content="article"><meta property="og:url" content="https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js-copy/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-04-21T00:00:00+02:00"><meta property="article:modified_time" content="2021-04-21T00:00:00+02:00"><meta property="og:site_name" content="my notes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Basic overview of constants/mutability in Python, C++ and JavaScript"><meta name=twitter:description content="Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.lkk7.com/notes/post/"},{"@type":"ListItem","position":3,"name":"Basic overview of constants/mutability in Python, C++ and JavaScript","item":"https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js-copy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Basic overview of constants/mutability in Python, C++ and JavaScript","name":"Basic overview of constants\/mutability in Python, C\u002b\u002b and JavaScript","description":"Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety.\n","keywords":["python","c++","javascript"],"articleBody":"Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety.\n(For Python, type hinting in every code snippet has been omitted for simplicity)\nPython Data model, objects Python’s reference [1] sums up its concept of objects in a concise way:\n“Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The is operator compares the identity of two objects; the id() function returns an integer representing its identity. […]\nThe value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable.”\nWe can check that every object has its identity, represented by an ID. Note that this is guaranteed to be a memory address in CPython, but not in other implementations.\n number = 1  id(number) 4402092336 Constants, mutability There is no concept of const in Python, so we cannot simply define a const variable like in many other languages. However, as said in earlier section, objects can be mutable or immutable.\nLet’s try to modify an object of type list (it is mutable) and see if it affects its identity.\n numbers = [1, 2, 3, 4, 5]  id(numbers) 4404611136  numbers[0] = 123  numbers [123, 2, 3, 4, 5]  id(numbers) 4404611136 As we see, modifying a mutable object does not change its identity. Let’s try to do the same thing with an object of type str, which is immutable.\n letters = \"abcdefg\"  letters[0] = \"!\" Traceback (most recent call last):  File \"\", line 1, in module TypeError: 'str' object does not support item assignment We cannot modify immutable objects in-place. If we want to modify a variable which holds a string, we have to assign a new string object to that variable.\n letters = \"abcdefg\"  id(letters) 4404659376  # Replace the occurence of 'a' with '!' by assigning a new string here  letters = letters.replace('a', '!', 1)  id(letters) 4404660336 Here are the essential data types divided on their mutability:\n Immutable: str, tuple, int, float, frozenset (an immutable set), bytes Mutable: list, dict, set, bytearray (a mutable version of bytes), user-defined classes.  If an immutable sequence like a tuple contains a mutable object (or really a reference to it) like a list, then this list can be modified in-place. We can’t modify the reference itself in the sequence, but we can modify the object it points to.\n immutable = (1, 2, 3, [100, 200, 300])  id(immutable[3]) 4302923264  immutable[3] = [10, 20, 30] # We can't modify the reference Traceback (most recent call last):  File \"\", line 1, in module TypeError: 'tuple' object does not support item assignment  immutable[3][2] = 999 # But we can get what it points to and modify that  id(immutable[3]) 4302923264  immutable (1, 2, 3, [100, 200, 999]) This points us to the fact that “immutability” doesn’t really mean “constness”. We can’t change the immutable object itself, but if it holds references to something mutable, we can modify that thing being pointed to.\nMoreover, we can just change what the variable holds.\n immutable = (1, 2, 3) # Variable points to an immutable object  immutable = (3, 2, 1) # So what, we can just change that Creating “constants” in Python We can emulate a constant like this:\n def GET_X(): ... return \"a1scdf8sfacd4cl\" ...  GET_X() 'a1scdf8sfacd4cl'  GET_X() = 100  File \"\", line 1  GET_X() = 100  ^ SyntaxError: cannot assign to function call But it requires us to remember about the function call parentheses. Also, it has the overhead of a function.\nFor classes, we can create read-only properties.\n class Something: ... def __init__(self, x): ... self._x = x ... @property ... def x(self): ... return self._x ...  something = Something(1)  something.x 1  something.x = 2 Traceback (most recent call last):  File \"\", line 1, in module AttributeError: can't set attribute An interesting case Python’s reference [1] says:\nDefault parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified.\nThat means that this is possible:\n def print_mirrored(numbers=[1,2,3]): ... numbers += numbers[::-1] ... print(numbers) ...  print_mirrored() [1, 2, 3, 3, 2, 1]  print_mirrored() [1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1] We see that changes to the default numbers parameter are saved between calls. If we don’t want that effect, we can choose to use None:\n def print_mirrored(numbers=None): ... if numbers is None: ... numbers = [1, 2, 3] ... numbers += numbers[::-1] ... print(numbers) ...  print_mirrored() [1, 2, 3, 3, 2, 1]  print_mirrored() [1, 2, 3, 3, 2, 1] C++ Const type qualifier and const-qualified member functions In contrast to Python, we can make objects constant and we do that by using a constant type qualifier. Cppreference [2] tells us what is a const object:\nAn object whose type is const-qualified, or a non-mutable subobject of a const object. Such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.\nWe declare the constness together with the type by the const keyword:\nconst int a = 0; // a = 10; // Error But the const keyword can also be used to const-qualify a member function (a function that is a member of a class) [2]. In such case, inside the body of that function *this is seen as const-qualified. Thus, we can’t modify any other members here and only member functions that are const-qualified can be called here.\nclass Something {  int member = 1;  void modify_member();  void modify_member_const() const;  void non_const_function() {}  void const_function() const {}; };  void Something::modify_member() {  member = 2; // Will work  non_const_function(); // Will work }  // Will not work void Something::modify_member_const() const {  const_function(); // Will work  // non_const_function(); // Won't work (error)  // member = 2; // Won't work (error) } There are some tools that make the compiler “forget” for a while that something is const in a specific context.\nThe first one is a mutable keyword. When we declare a class member as mutable, it can be modified even in const-qualified member functions.\nclass Something {  int member = 1;  mutable int mutable_member = 1;  void const_function() const; };  void Something::const_function() const{  mutable_member = 2; // Will work  // member = 2; // Won't work (error) } As cppreference says [2]: Mutable is used to specify that the member does not affect the externally visible state of the class. Example usage includes mutexes.\nAnother tool used to “forget” the constness of something is const_cast. It can be used to remove constness from const pointers/references that point to a non-const object.\nint i = 1; const int* ptr = \u0026i; *const_castint*(ptr) = 2; If the object (i) pointed to was actually const, this would lead to undefined behavior. const_cast is used rather rarely.\nconstexpr There’s also the great constexpr, about which cppreference [2] says:\nThe constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given). The “at-compile-time” thing is still evolving, with consteval and constinit coming in the future. That’s why I will probably focus on these things in a different post.\nAn interesting case Const declarations might get tricky when using type aliases.\nusing int_ptr = int*;  int x = 1; const int* first = \u0026x; // const int* as expected const int_ptr second = \u0026x; // This is actually int* const The first pointer will be of type const int* (non-const pointer to a const int). However, compiler will make the second one a int* const (const pointer to a non-const int). Why is this the case? It’s because the second pointer gets evaluated to int_ptr const second, which gives int* const second.\nA Good FAQ about constness in C++ https://isocpp.org/wiki/faq/const-correctness\nJavaScript Constants, mutability All primitive data types (string, number, bigint, boolean, undefined, symbol, null) are immutable [3]. Objects and arrays are mutable. As in Python, variables pointing to immutable data can just start pointing to a new value.\nlet immutable = \"x\"; // the \"x\" is immutable immutable = \"y\"; // but we can just abandon the \"x\"  let x = {a: 1}; x.a = 100; // We can modify an object console.log(x); // {a: 100} ES6 introduced the ‘const’ keyword for variables. This prevents reassignment:\nconst value = 1; value = 2; // Uncaught TypeError: Assignment to constant variable. We have to initialize a const variable immediately:\nconst x; // Uncaught SyntaxError: Missing initializer in const declaration const, just like let, has block scope:\nconst x = 1; {  const x = 2;  console.log(x); // 2 } console.log(x); // 1 Important: const does not make the object pointed to immutable – it just prevents reassignment:\nconst x = {a: 1}; x.a = 100; console.log(x); // {a: 100} To make an object immutable, we can use Object.freeze. This does not work on nested objects:\nlet x = {a: 1, nested: {b: 1}}; Object.freeze(x); x.a = 2; x.new = \"new\"; x.nested.b = 2; console.log(x); // {a: 1, nested: {b: 2}} As we can see, this situation is very similar to Python’s case (immutable tuple holding a mutable list).\nAn interesting case Function declarations get hoisted to current scope’s top, so the function can be used before the declaration.\nconsole.log(linearFunction(2, 1, 10)); // 21 function linearFunction(a, b, x) {  return a * x + b; } A const arrow function prevents this (because it is block-scoped) while also preventing reassignment:\nconsole.log(linearFunction(2, 1, 10)); // Error const linearFunction = (a, b, x) = a * x + b; console.log(linearFunction(2, 1, 10)); // 21 linearFunction = () = {} // Error Another option is a mix of these two options:\nconsole.log(linearFunction(2, 1, 10)); // Error const linearFunction = function linearFunction(a, b, x) {  return a * x + b; } console.log(linearFunction(2, 1, 10)); // 21 linearFunction = function linearFunction(a, b, x) {}; // Error Which approach is better depends on the situation. Arrow functions have their limitations as seen here.\nSources:  [1] https://docs.python.org/3/reference Python Software Foundation. The Python Language Reference [2] https://en.cppreference.com cppreference.com – C and C++ reference [3] https://developer.mozilla.org – MDN Web Docs ","wordCount":"1870","inLanguage":"en","datePublished":"2021-04-21T00:00:00+02:00","dateModified":"2021-04-21T00:00:00+02:00","author":{"@type":"Person","name":"lkk7"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lkk7.com/notes/post/2021-06-20-basic-overview-of-constants-mutability-in-python-cpp-js-copy/"},"publisher":{"@type":"Organization","name":"lkk7/notes","logo":{"@type":"ImageObject","url":"https://www.lkk7.com/notes/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.lkk7.com/notes accesskey=h title="lkk7/notes (Alt + H)">lkk7/notes</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.lkk7.com/notes/ title="home (notes)"><span>home (notes)</span></a></li><li><a href=https://www.lkk7.com/notes/archives title=archives><span>archives</span></a></li><li><a href=https://www.lkk7.com title="my page"><span>my page</span></a></li><li><a href=https://www.lkk7.com/notes/tags title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.lkk7.com/notes>Home</a>&nbsp;»&nbsp;<a href=https://www.lkk7.com/notes/post/>Posts</a></div><h1 class=post-title>Basic overview of constants/mutability in Python, C++ and JavaScript</h1><div class=post-meta><span title="2021-04-21 00:00:00 +0200 +0200">April 21, 2021</span>&nbsp;·&nbsp;lkk7</div></header><div class=post-content><p>Here I compare the concept of constants, mutability and things around it – across Python, C++ and JavaScript. Of course, this note does not describe the topic in its entirety.</p><p><strong>(For Python, type hinting in every code snippet has been omitted for simplicity)</strong></p><h2 id=python>Python<a hidden class=anchor aria-hidden=true href=#python>#</a></h2><h3 id=data-model-objects>Data model, objects<a hidden class=anchor aria-hidden=true href=#data-model-objects>#</a></h3><p>Python&rsquo;s reference [1] sums up its concept of objects in a concise way:<br><em>&ldquo;Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The <code>is</code> operator compares the identity of two objects; the <code>id()</code> function returns an integer representing its identity. [&mldr;]<br>The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable.&rdquo;</em></p><p>We can check that every object has its identity, represented by an ID. Note that this is guaranteed to be a memory address in CPython, but not in other implementations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> number <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(number)
</span></span><span style=display:flex><span><span style=color:#ae81ff>4402092336</span>
</span></span></code></pre></div><h3 id=constants-mutability>Constants, mutability<a hidden class=anchor aria-hidden=true href=#constants-mutability>#</a></h3><p>There is no concept of <code>const</code> in Python, so we cannot simply define a <code>const</code> variable like in many other languages.
However, as said in earlier section, objects can be mutable or immutable.<br>Let&rsquo;s try to modify an object of type <code>list</code> (it is mutable) and see if it affects its identity.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(numbers)
</span></span><span style=display:flex><span><span style=color:#ae81ff>4404611136</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> numbers[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> numbers
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>123</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(numbers)
</span></span><span style=display:flex><span><span style=color:#ae81ff>4404611136</span>
</span></span></code></pre></div><p>As we see, modifying a mutable object does not change its identity.
Let&rsquo;s try to do the same thing with an object of type <code>str</code>, which is immutable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> letters <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcdefg&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> letters[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;!&#34;</span>
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#ae81ff>1</span>, <span style=color:#f92672>in</span> <span style=color:#f92672>&lt;</span>module<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TypeError</span>: <span style=color:#e6db74>&#39;str&#39;</span> object does <span style=color:#f92672>not</span> support item assignment
</span></span></code></pre></div><p>We cannot modify immutable objects in-place. If we want to modify a variable which holds a string, we have to assign a new string object to that variable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> letters <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcdefg&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(letters)
</span></span><span style=display:flex><span><span style=color:#ae81ff>4404659376</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#75715e># Replace the occurence of &#39;a&#39; with &#39;!&#39; by assigning a new string here</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> letters <span style=color:#f92672>=</span> letters<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;!&#39;</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(letters)
</span></span><span style=display:flex><span><span style=color:#ae81ff>4404660336</span>
</span></span></code></pre></div><p>Here are the essential data types divided on their mutability:</p><ul><li>Immutable: <code>str</code>, <code>tuple</code>, <code>int</code>, <code>float</code>, <code>frozenset</code> (an immutable <code>set</code>), <code>bytes</code></li><li>Mutable: <code>list</code>, <code>dict</code>, <code>set</code>, <code>bytearray</code> (a mutable version of <code>bytes</code>), user-defined classes.</li></ul><p>If an immutable sequence like a <code>tuple</code> contains a mutable object (or really a reference to it) like a <code>list</code>, then this list can be modified in-place. We can&rsquo;t modify the reference itself in the sequence, but we can modify the object it points to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> immutable <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, [<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>300</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(immutable[<span style=color:#ae81ff>3</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>4302923264</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> immutable[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>] <span style=color:#75715e># We can&#39;t modify the reference</span>
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#ae81ff>1</span>, <span style=color:#f92672>in</span> <span style=color:#f92672>&lt;</span>module<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TypeError</span>: <span style=color:#e6db74>&#39;tuple&#39;</span> object does <span style=color:#f92672>not</span> support item assignment
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> immutable[<span style=color:#ae81ff>3</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>999</span> <span style=color:#75715e># But we can get what it points to and modify that</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> id(immutable[<span style=color:#ae81ff>3</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>4302923264</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> immutable
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, [<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>999</span>])
</span></span></code></pre></div><p>This points us to the fact that &ldquo;immutability&rdquo; doesn&rsquo;t really mean &ldquo;constness&rdquo;.
We can&rsquo;t change the immutable object itself, but if it holds references to something mutable, we can modify that thing being pointed to.<br>Moreover, we can just change what the variable holds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> immutable <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>) <span style=color:#75715e># Variable points to an immutable object</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> immutable <span style=color:#f92672>=</span> (<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>) <span style=color:#75715e># So what, we can just change that</span>
</span></span></code></pre></div><h3 id=creating-constants-in-python>Creating &ldquo;constants&rdquo; in Python<a hidden class=anchor aria-hidden=true href=#creating-constants-in-python>#</a></h3><p>We can emulate a constant like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GET_X</span>():
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;a1scdf8sfacd4cl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> GET_X()
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;a1scdf8sfacd4cl&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> GET_X() <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    GET_X() <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>^</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SyntaxError</span>: cannot assign to function call
</span></span></code></pre></div><p>But it requires us to remember about the function call parentheses. Also, it has the overhead of a function.<br>For classes, we can create read-only properties.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>def</span> __init__(self, x):
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>         self<span style=color:#f92672>.</span>_x <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>x</span>(self):
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>         <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_x
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> something <span style=color:#f92672>=</span> Something(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> something<span style=color:#f92672>.</span>x
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> something<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#ae81ff>1</span>, <span style=color:#f92672>in</span> <span style=color:#f92672>&lt;</span>module<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>AttributeError</span>: can<span style=color:#e6db74>&#39;t set attribute</span>
</span></span></code></pre></div><h3 id=an-interesting-case>An interesting case<a hidden class=anchor aria-hidden=true href=#an-interesting-case>#</a></h3><p>Python&rsquo;s reference [1] says:<br><em>Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified.</em></p><p>That means that this is possible:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_mirrored</span>(numbers<span style=color:#f92672>=</span>[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]):
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     numbers <span style=color:#f92672>+=</span> numbers[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     print(numbers)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print_mirrored()
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print_mirrored()
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><p>We see that changes to the default <code>numbers</code> parameter are saved between calls. If we don&rsquo;t want that effect, we can choose to use <code>None</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_mirrored</span>(numbers<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>if</span> numbers <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>         numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     numbers <span style=color:#f92672>+=</span> numbers[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     print(numbers)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print_mirrored()
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print_mirrored()
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h2 id=c>C++<a hidden class=anchor aria-hidden=true href=#c>#</a></h2><h3 id=const-type-qualifier-and-const-qualified-member-functions>Const type qualifier and const-qualified member functions<a hidden class=anchor aria-hidden=true href=#const-type-qualifier-and-const-qualified-member-functions>#</a></h3><p>In contrast to Python, we can make objects constant and we do that by using a constant type qualifier. Cppreference [2] tells us what is a const object:<br><em>An object whose type is const-qualified, or a non-mutable subobject of a const object. Such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.</em></p><p>We declare the constness together with the type by the <code>const</code> keyword:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// a = 10;       // Error
</span></span></span></code></pre></div><p>But the <code>const</code> keyword can also be used to const-qualify a member function (a function that is a member of a class) [2]. In such case, inside the body of that function <code>*this</code> is seen as const-qualified. Thus, we can&rsquo;t modify any other members here and only member functions that are const-qualified can be called here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> member <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>modify_member</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>modify_member_const</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>non_const_function</span>() {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>const_function</span>() <span style=color:#66d9ef>const</span> {};
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Something<span style=color:#f92672>::</span>modify_member() {
</span></span><span style=display:flex><span>    member <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;           <span style=color:#75715e>// Will work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    non_const_function(); <span style=color:#75715e>// Will work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Will not work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Something<span style=color:#f92672>::</span>modify_member_const() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    const_function();        <span style=color:#75715e>// Will work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// non_const_function(); // Won&#39;t work (error)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// member = 2;           // Won&#39;t work (error)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>There are some tools that make the compiler &ldquo;forget&rdquo; for a while that something is const in a specific context.</p><p>The first one is a <code>mutable</code> keyword. When we declare a class member as <code>mutable</code>, it can be modified even in const-qualified member functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> member <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutable</span> <span style=color:#66d9ef>int</span> mutable_member <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>const_function</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Something<span style=color:#f92672>::</span>const_function() <span style=color:#66d9ef>const</span>{
</span></span><span style=display:flex><span>    mutable_member <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// Will work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// member = 2;         // Won&#39;t work (error)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>As cppreference says [2]: <em>Mutable is used to specify that the member does not affect the externally visible state of the class</em>. Example usage includes mutexes.</p><p>Another tool used to &ldquo;forget&rdquo; the constness of something is <code>const_cast</code>. It can be used to remove constness from const pointers/references that point to a non-const object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>i;
</span></span><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;</span>(ptr) <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p><strong>If the object (<code>i</code>) pointed to was actually <code>const</code>, this would lead to undefined behavior.</strong> <code>const_cast</code> is used rather rarely.</p><h3 id=constexpr>constexpr<a hidden class=anchor aria-hidden=true href=#constexpr>#</a></h3><p>There&rsquo;s also the great <code>constexpr</code>, about which cppreference [2] says:<br><em>The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given).</em>
The &ldquo;at-compile-time&rdquo; thing is still evolving, with <code>consteval</code> and <code>constinit</code> coming in the future. That&rsquo;s why I will probably focus on these things in a different post.</p><h3 id=an-interesting-case-1>An interesting case<a hidden class=anchor aria-hidden=true href=#an-interesting-case-1>#</a></h3><p>Const declarations might get tricky when using type aliases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> int_ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> first <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x;     <span style=color:#75715e>// const int* as expected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> int_ptr second <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x; <span style=color:#75715e>// This is actually int* const
</span></span></span></code></pre></div><p>The <code>first</code> pointer will be of type <code>const int*</code> (non-const pointer to a const int). However, compiler will make the <code>second</code> one a <code>int* const</code> (const pointer to a non-const int). Why is this the case? It&rsquo;s because the <code>second</code> pointer gets evaluated to <code>int_ptr const second</code>, which gives <code>int* const second</code>.</p><h3 id=a-good-faq-about-constness-in-c>A Good FAQ about constness in C++<a hidden class=anchor aria-hidden=true href=#a-good-faq-about-constness-in-c>#</a></h3><p><a href=https://isocpp.org/wiki/faq/const-correctness>https://isocpp.org/wiki/faq/const-correctness</a></p><h2 id=javascript>JavaScript<a hidden class=anchor aria-hidden=true href=#javascript>#</a></h2><h3 id=constants-mutability-1>Constants, mutability<a hidden class=anchor aria-hidden=true href=#constants-mutability-1>#</a></h3><p>All primitive data types (string, number, bigint, boolean, undefined, symbol, null) are immutable [3]. Objects and arrays are mutable. As in Python, variables pointing to immutable data can just start pointing to a new value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>immutable</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x&#34;</span>;   <span style=color:#75715e>// the &#34;x&#34; is immutable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>immutable</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;y&#34;</span>;       <span style=color:#75715e>// but we can just abandon the &#34;x&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;             <span style=color:#75715e>// We can modify an object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>);        <span style=color:#75715e>// {a: 100}
</span></span></span></code></pre></div><p>ES6 introduced the &lsquo;const&rsquo; keyword for variables. This prevents reassignment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// Uncaught TypeError: Assignment to constant variable.
</span></span></span></code></pre></div><p>We have to initialize a <code>const</code> variable immediately:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>x</span>; <span style=color:#75715e>// Uncaught SyntaxError: Missing initializer in const declaration
</span></span></span></code></pre></div><p><code>const</code>, just like <code>let</code>, has block scope:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>); <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>);     <span style=color:#75715e>// 1
</span></span></span></code></pre></div><p>Important: <code>const</code> does not make the object pointed to immutable – it just prevents reassignment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>); <span style=color:#75715e>// {a: 100}
</span></span></span></code></pre></div><p>To make an object immutable, we can use <code>Object.freeze</code>. This does not work on nested objects:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>nested</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>}};
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>freeze</span>(<span style=color:#a6e22e>x</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span>.<span style=color:#66d9ef>new</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;new&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>nested</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>); <span style=color:#75715e>// {a: 1, nested: {b: 2}}
</span></span></span></code></pre></div><p>As we can see, this situation is very similar to Python&rsquo;s case (immutable <code>tuple</code> holding a mutable <code>list</code>).</p><h3 id=an-interesting-case-2>An interesting case<a hidden class=anchor aria-hidden=true href=#an-interesting-case-2>#</a></h3><p>Function declarations get hoisted to current scope&rsquo;s top, so the function can be used before the declaration.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>linearFunction</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>)); <span style=color:#75715e>// 21
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>linearFunction</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>x</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A <code>const</code> arrow function prevents this (because it is block-scoped) while also preventing reassignment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>linearFunction</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>));          <span style=color:#75715e>// Error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>linearFunction</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>x</span>) =&gt; <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>linearFunction</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>));          <span style=color:#75715e>// 21
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>linearFunction</span> <span style=color:#f92672>=</span> () =&gt; {}                       <span style=color:#75715e>// Error
</span></span></span></code></pre></div><p>Another option is a mix of these two options:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>linearFunction</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>));                    <span style=color:#75715e>// Error  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>linearFunction</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>linearFunction</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>x</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>linearFunction</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>));                    <span style=color:#75715e>// 21
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>linearFunction</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>linearFunction</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>x</span>) {};     <span style=color:#75715e>// Error
</span></span></span></code></pre></div><p>Which approach is better depends on the situation. Arrow functions have their limitations <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions>as seen here</a>.</p><h2 id=sources>Sources:<a hidden class=anchor aria-hidden=true href=#sources>#</a></h2><ul><li>[1] <a href=https://docs.python.org/3/reference>https://docs.python.org/3/reference</a> Python Software Foundation. The Python Language Reference</li><li>[2] <a href=https://en.cppreference.com>https://en.cppreference.com</a> cppreference.com – C and C++ reference</li><li>[3] <a href=https://developer.mozilla.org>https://developer.mozilla.org</a> – MDN Web Docs</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.lkk7.com/notes/tags/python/>python</a></li><li><a href=https://www.lkk7.com/notes/tags/c++/>c++</a></li><li><a href=https://www.lkk7.com/notes/tags/javascript/>javascript</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.lkk7.com/notes>lkk7/notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>